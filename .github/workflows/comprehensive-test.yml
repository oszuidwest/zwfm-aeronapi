name: Comprehensive Test
permissions:
  contents: read
on:
  pull_request:
    branches: [main]
  workflow_call:
    inputs:
      skip_tests:
        description: 'Skip tests (for edge releases)'
        type: boolean
        required: false
        default: false
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (for edge releases)'
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  POSTGRES_USER: aeron
  POSTGRES_PASSWORD: aeron123
  POSTGRES_DB: aeron_db
  API_PORT: 8888
  DB_PORT: 5433
  API_KEY: test-api-key-12345
  # Known IDs from test fixtures
  ARTIST_ID: "9e37ff1f-7823-43ce-93d0-12fc1c2edb8b"
  BLOF_ID: "add55a6e-2068-4114-b82a-e0729881f0be"
  FAKE_UUID: "00000000-0000-4000-8000-000000000001"

jobs:
  build:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_tests != true }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Build application
        run: |
          go build -ldflags="-X main.Version=test -X main.Commit=${{ github.sha }} -X main.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)" -o zwfm-aerontoolbox .
          ./zwfm-aerontoolbox -version

      - name: Upload binary
        uses: actions/upload-artifact@v6
        with:
          name: binary
          path: zwfm-aerontoolbox
          retention-days: 1

  lint:
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_tests != true }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'
          cache: true

      - name: Download dependencies
        run: go mod download

      - name: Check formatting (gofmt)
        run: |
          UNFORMATTED=$(gofmt -s -l .)
          if [ -n "$UNFORMATTED" ]; then
            echo "::error::De volgende bestanden zijn niet correct geformatteerd:"
            echo "$UNFORMATTED"
            exit 1
          fi
          echo "Alle bestanden zijn correct geformatteerd"

      - name: Run go vet
        run: go vet ./...

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v9
        with:
          version: latest
          args: --timeout=5m

      - name: Check for dead code
        run: go run golang.org/x/tools/cmd/deadcode@latest ./...

      - name: Run govulncheck
        run: go run golang.org/x/vuln/cmd/govulncheck@latest ./...

  integration:
    needs: build
    runs-on: ubuntu-latest
    if: ${{ inputs.skip_tests != true }}
    strategy:
      fail-fast: false
      matrix:
        suite:
          - database
          - api-basic
          - artists
          - tracks
          - maintenance
          - backup
          - system-validation
          - s3
          - edge-cases

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download binary
        uses: actions/download-artifact@v7
        with:
          name: binary

      - name: Make binary executable
        run: chmod +x ./zwfm-aerontoolbox

      - name: Install test dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq imagemagick
          # Install postgresql-client for all suites except system-validation
          if [ "${{ matrix.suite }}" != "system-validation" ]; then
            sudo apt-get install -y postgresql-client
          fi

      - name: Start test database
        run: |
          cd tests
          docker compose -f docker-compose.test.yml up -d

      - name: Wait for database
        run: |
          echo "Wachten op database..."
          for i in {1..30}; do
            if docker exec aeron-test-db pg_isready -U aeron 2>/dev/null; then
              sleep 2
              break
            fi
            sleep 1
          done
          ARTIST_COUNT=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT COUNT(*) FROM aeron.artist;" 2>/dev/null | tr -d ' ')
          echo "Database klaar - $ARTIST_COUNT artiesten geladen"
          [ -n "$ARTIST_COUNT" ] && [ "$ARTIST_COUNT" -gt 0 ]

      - name: Create test configuration
        run: |
          cat > test_config.json << 'EOF'
          {
            "database": {
              "host": "localhost",
              "port": "5433",
              "name": "aeron_db",
              "user": "aeron",
              "password": "aeron123",
              "schema": "aeron",
              "sslmode": "disable"
            },
            "image": {
              "target_width": 1280,
              "target_height": 1280,
              "quality": 90,
              "reject_smaller": true
            },
            "api": {
              "enabled": true,
              "keys": ["test-api-key-12345", "another-test-key-67890"]
            },
            "backup": {
              "enabled": true,
              "path": "/tmp/backups",
              "retention_days": 30,
              "max_backups": 5,
              "default_compression": 9
            }
          }
          EOF
          mkdir -p /tmp/backups

      - name: Create test images
        if: matrix.suite == 'artists' || matrix.suite == 'tracks' || matrix.suite == 'edge-cases'
        run: |
          convert -size 100x100 xc:red test_small.png
          convert -size 2000x2000 xc:blue test_large.png
          echo "Test images aangemaakt (100x100 en 2000x2000)"

      - name: Start API server
        run: |
          ./zwfm-aerontoolbox -config=test_config.json -port=${{ env.API_PORT }} &
          echo $! > api.pid
          for i in {1..30}; do
            curl -sf http://localhost:${{ env.API_PORT }}/api/health > /dev/null 2>&1 && break
            sleep 1
          done
          echo "API server gestart op poort ${{ env.API_PORT }}"

      # ==================== DATABASE TESTS ====================
      - name: "Database: Schema exists"
        if: matrix.suite == 'database'
        run: |
          echo "Controleren of 'aeron' schema bestaat..."
          RESULT=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t \
            -c "SELECT schema_name FROM information_schema.schemata WHERE schema_name = 'aeron';")
          if echo "$RESULT" | grep -q 'aeron'; then
            echo "Schema 'aeron' gevonden"
          else
            echo "::error::Schema 'aeron' niet gevonden"
            exit 1
          fi

      - name: "Database: Required tables exist"
        if: matrix.suite == 'database'
        run: |
          echo "Controleren of vereiste tabellen bestaan..."
          for TABLE in artist track; do
            RESULT=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t \
              -c "SELECT table_name FROM information_schema.tables WHERE table_schema = 'aeron' AND table_name = '$TABLE';")
            if echo "$RESULT" | grep -q "$TABLE"; then
              echo "Tabel '$TABLE' gevonden"
            else
              echo "::error::Tabel '$TABLE' niet gevonden"
              exit 1
            fi
          done

      - name: "Database: Verify data counts"
        if: matrix.suite == 'database'
        run: |
          ARTIST_COUNT=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT COUNT(*) FROM aeron.artist;" | tr -d ' ')
          TRACK_COUNT=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT COUNT(*) FROM aeron.track;" | tr -d ' ')
          ARTISTS_WITH_IMG=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT COUNT(*) FROM aeron.artist WHERE picture IS NOT NULL;" | tr -d ' ')

          echo "Artiesten: $ARTIST_COUNT (verwacht: 1000)"
          echo "Tracks: $TRACK_COUNT (verwacht: 1100)"
          echo "Artiesten met afbeelding: $ARTISTS_WITH_IMG (verwacht: >0)"

          FAILED=0
          [ "$ARTIST_COUNT" -ne 1000 ] && echo "::error::Aantal artiesten klopt niet" && FAILED=1
          [ "$TRACK_COUNT" -ne 1100 ] && echo "::error::Aantal tracks klopt niet" && FAILED=1
          [ "$ARTISTS_WITH_IMG" -le 0 ] && echo "::error::Geen artiesten met afbeelding" && FAILED=1
          exit $FAILED

      # ==================== API BASIC TESTS ====================
      - name: "API: Health endpoint"
        if: matrix.suite == 'api-basic'
        run: |
          echo "GET /api/health"
          RESPONSE=$(curl -s http://localhost:${{ env.API_PORT }}/api/health)
          echo "Response: $RESPONSE"
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Health check OK"
          else
            echo "::error::Health check gefaald - success=$SUCCESS"
            exit 1
          fi

      - name: "API: Authentication required"
        if: matrix.suite == 'api-basic'
        run: |
          echo "GET /api/artists (zonder API key)"
          RESPONSE=$(curl -s http://localhost:${{ env.API_PORT }}/api/artists)
          echo "Response: $RESPONSE"
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: request zonder API key wordt geweigerd"
          else
            echo "::error::Request zonder API key zou geweigerd moeten worden"
            exit 1
          fi

      - name: "API: Valid API key accepted"
        if: matrix.suite == 'api-basic'
        run: |
          echo "GET /api/artists (met geldige API key)"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/artists)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          TOTAL=$(echo "$RESPONSE" | jq -r '.data.total')
          if [ "$SUCCESS" = "true" ]; then
            echo "Correct: API key geaccepteerd - $TOTAL artiesten gevonden"
          else
            echo "::error::Geldige API key werd niet geaccepteerd"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "API: Invalid API key rejected"
        if: matrix.suite == 'api-basic'
        run: |
          echo "GET /api/artists (met ongeldige API key)"
          RESPONSE=$(curl -s -H 'X-API-Key: invalid-key' http://localhost:${{ env.API_PORT }}/api/artists)
          echo "Response: $RESPONSE"
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: ongeldige API key wordt geweigerd"
          else
            echo "::error::Ongeldige API key zou geweigerd moeten worden"
            exit 1
          fi

      - name: "API: Method not allowed returns 405"
        if: matrix.suite == 'api-basic'
        run: |
          echo "PUT /api/artists (niet toegestane methode)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X PUT -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/artists)
          echo "HTTP status: $HTTP_CODE (verwacht: 405)"
          if [ "$HTTP_CODE" = "405" ]; then
            echo "Correct: PUT methode geeft 405 Method Not Allowed"
          else
            echo "::error::Verwachtte HTTP 405, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "API: Invalid endpoint returns 404"
        if: matrix.suite == 'api-basic'
        run: |
          echo "GET /api/invalid (niet-bestaand endpoint)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/invalid)
          echo "HTTP status: $HTTP_CODE (verwacht: 404)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: ongeldig endpoint geeft 404 Not Found"
          else
            echo "::error::Verwachtte HTTP 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "API: Playlist endpoint"
        if: matrix.suite == 'api-basic'
        run: |
          echo "Playlist data bijwerken naar vandaag..."
          docker exec aeron-test-db psql -U aeron -d aeron_db -c "UPDATE aeron.playlistitem SET startdatetime = CURRENT_DATE + (startdatetime::time)" > /dev/null
          echo "GET /api/playlist"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/playlist)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          BLOCKS=$(echo "$RESPONSE" | jq '.data | length')
          if [ "$SUCCESS" = "true" ]; then
            echo "Correct: playlist opgehaald met $BLOCKS blokken"
          else
            echo "::error::Playlist endpoint gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "API: Playlist block structure"
        if: matrix.suite == 'api-basic'
        run: |
          echo "Controleren of playlist blokken de juiste velden hebben..."
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/playlist)
          REQUIRED_FIELDS="blockid name start_time end_time date tracks"
          FIRST_BLOCK=$(echo "$RESPONSE" | jq '.data[0]')
          echo "Eerste blok: $FIRST_BLOCK"
          for FIELD in $REQUIRED_FIELDS; do
            if echo "$FIRST_BLOCK" | jq -e "has(\"$FIELD\")" > /dev/null; then
              echo "Veld '$FIELD' aanwezig"
            else
              echo "::error::Verplicht veld '$FIELD' ontbreekt in playlist blok"
              exit 1
            fi
          done

      - name: "API: Playlist track structure"
        if: matrix.suite == 'api-basic'
        run: |
          echo "Controleren of playlist tracks de juiste velden hebben..."
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/playlist)
          REQUIRED_FIELDS="trackid tracktitle artistid artistname start_time"
          FIRST_TRACK=$(echo "$RESPONSE" | jq '.data[0].tracks[0]')
          echo "Eerste track: $FIRST_TRACK"
          for FIELD in $REQUIRED_FIELDS; do
            if echo "$FIRST_TRACK" | jq -e "has(\"$FIELD\")" > /dev/null; then
              echo "Veld '$FIELD' aanwezig"
            else
              echo "::error::Verplicht veld '$FIELD' ontbreekt in playlist track"
              exit 1
            fi
          done

      - name: "API: Auth disabled mode"
        if: matrix.suite == 'api-basic'
        run: |
          echo "API server herstarten zonder authenticatie..."
          kill $(cat api.pid) 2>/dev/null || true
          cat > test_no_auth.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 1280, "target_height": 1280, "quality": 90 },
            "api": { "enabled": false, "keys": [] }
          }
          EOF
          ./zwfm-aerontoolbox -config=test_no_auth.json -port=${{ env.API_PORT }} &
          echo $! > api.pid
          for i in {1..30}; do curl -sf http://localhost:${{ env.API_PORT }}/api/health > /dev/null 2>&1 && break; sleep 1; done
          echo "GET /api/artists (zonder API key, auth uitgeschakeld)"
          RESPONSE=$(curl -s http://localhost:${{ env.API_PORT }}/api/artists)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Correct: request zonder API key werkt als auth uitgeschakeld is"
          else
            echo "::error::Request zou moeten werken zonder auth als api.enabled=false"
            echo "Response: $RESPONSE"
            exit 1
          fi

      # ==================== ARTIST TESTS ====================
      - name: "Artist: Get statistics"
        if: matrix.suite == 'artists'
        run: |
          echo "GET /api/artists"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/artists)
          TOTAL=$(echo "$RESPONSE" | jq -r '.data.total')
          WITH_IMG=$(echo "$RESPONSE" | jq -r '.data.with_images')
          WITHOUT_IMG=$(echo "$RESPONSE" | jq -r '.data.without_images')
          echo "Totaal: $TOTAL (verwacht: 1000)"
          echo "Met afbeelding: $WITH_IMG (verwacht: >0)"
          echo "Zonder afbeelding: $WITHOUT_IMG (verwacht: >0)"
          FAILED=0
          [ "$TOTAL" -ne 1000 ] && echo "::error::Totaal aantal artiesten klopt niet" && FAILED=1
          [ "$WITH_IMG" -le 0 ] && echo "::error::Geen artiesten met afbeelding" && FAILED=1
          [ "$WITHOUT_IMG" -le 0 ] && echo "::error::Geen artiesten zonder afbeelding" && FAILED=1
          exit $FAILED

      - name: "Artist: Get single artist"
        if: matrix.suite == 'artists'
        run: |
          echo "GET /api/artists/${{ env.ARTIST_ID }}"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.ARTIST_ID }}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          ARTIST_NAME=$(echo "$RESPONSE" | jq -r '.data.artistname')
          if [ "$SUCCESS" = "true" ]; then
            echo "Artiest gevonden: $ARTIST_NAME"
          else
            echo "::error::Artiest niet gevonden"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Artist: Non-existent returns 404"
        if: matrix.suite == 'artists'
        run: |
          echo "GET /api/artists/${{ env.FAKE_UUID }} (niet-bestaande artiest)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.FAKE_UUID }}")
          echo "HTTP status: $HTTP_CODE (verwacht: 404)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: niet-bestaande artiest geeft 404"
          else
            echo "::error::Verwachtte HTTP 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Artist: Upload image via URL"
        if: matrix.suite == 'artists'
        run: |
          echo "POST /api/artists/${{ env.ARTIST_ID }}/image (via URL)"
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.ARTIST_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/1500"}' -m 15)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Afbeelding succesvol geupload via URL"
          else
            echo "::error::Upload via URL gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Artist: Upload image via base64"
        if: matrix.suite == 'artists'
        run: |
          echo "POST /api/artists/${{ env.BLOF_ID }}/image (via base64)"
          BASE64_IMAGE=$(base64 -w 0 < test_large.png)
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.BLOF_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d "{\"image\":\"data:image/png;base64,$BASE64_IMAGE\"}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Afbeelding succesvol geupload via base64"
          else
            echo "::error::Upload via base64 gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Artist: Get image"
        if: matrix.suite == 'artists'
        run: |
          echo "GET /api/artists/${{ env.BLOF_ID }}/image"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.BLOF_ID }}/image")
          echo "HTTP status: $HTTP_CODE (verwacht: 200)"
          if [ "$HTTP_CODE" = "200" ]; then
            echo "Correct: afbeelding kan worden opgehaald"
          else
            echo "::error::Verwachtte HTTP 200, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Artist: Delete image"
        if: matrix.suite == 'artists'
        run: |
          echo "DELETE /api/artists/${{ env.BLOF_ID }}/image"
          RESPONSE=$(curl -s -X DELETE -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.BLOF_ID }}/image")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Afbeelding succesvol verwijderd"
          else
            echo "::error::Verwijderen van afbeelding gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Artist: Deleted image returns 404"
        if: matrix.suite == 'artists'
        run: |
          echo "GET /api/artists/${{ env.BLOF_ID }}/image (na verwijderen)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.BLOF_ID }}/image")
          echo "HTTP status: $HTTP_CODE (verwacht: 404)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: verwijderde afbeelding geeft 404"
          else
            echo "::error::Verwachtte HTTP 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Artist: Bulk delete requires confirmation"
        if: matrix.suite == 'artists'
        run: |
          echo "DELETE /api/artists/bulk-delete (zonder bevestiging)"
          RESPONSE=$(curl -s -X DELETE -H "X-API-Key: ${{ env.API_KEY }}" \
            http://localhost:${{ env.API_PORT }}/api/artists/bulk-delete)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: bulk delete zonder bevestiging wordt geweigerd"
          else
            echo "::error::Bulk delete zonder bevestiging zou geweigerd moeten worden"
            exit 1
          fi

      # ==================== TRACK TESTS ====================
      - name: "Track: Get statistics"
        if: matrix.suite == 'tracks'
        run: |
          echo "GET /api/tracks"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/tracks)
          TOTAL=$(echo "$RESPONSE" | jq -r '.data.total')
          echo "Totaal aantal tracks: $TOTAL (verwacht: 1100)"
          if [ "$TOTAL" -eq 1100 ]; then
            echo "Correct: $TOTAL tracks gevonden"
          else
            echo "::error::Verwachtte 1100 tracks, kreeg $TOTAL"
            exit 1
          fi
          # Save TRACK_ID for subsequent tests
          TRACK_ID=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT titleid FROM aeron.track LIMIT 1;" | tr -d ' ')
          echo "TRACK_ID=$TRACK_ID" >> $GITHUB_ENV
          echo "Test track ID: $TRACK_ID"

      - name: "Track: Get single track"
        if: matrix.suite == 'tracks'
        run: |
          echo "GET /api/tracks/${{ env.TRACK_ID }}"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" "http://localhost:${{ env.API_PORT }}/api/tracks/${{ env.TRACK_ID }}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          TITLE=$(echo "$RESPONSE" | jq -r '.data.title')
          if [ "$SUCCESS" = "true" ]; then
            echo "Track gevonden: $TITLE"
          else
            echo "::error::Track niet gevonden"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Track: Non-existent returns 404"
        if: matrix.suite == 'tracks'
        run: |
          echo "GET /api/tracks/${{ env.FAKE_UUID }} (niet-bestaande track)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/tracks/${{ env.FAKE_UUID }}")
          echo "HTTP status: $HTTP_CODE (verwacht: 404)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: niet-bestaande track geeft 404"
          else
            echo "::error::Verwachtte HTTP 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Track: Upload image"
        if: matrix.suite == 'tracks'
        run: |
          echo "POST /api/tracks/${{ env.TRACK_ID }}/image"
          BASE64_IMAGE=$(base64 -w 0 < test_large.png)
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/tracks/${{ env.TRACK_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d "{\"image\":\"data:image/png;base64,$BASE64_IMAGE\"}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Afbeelding succesvol geupload naar track"
          else
            echo "::error::Track image upload gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Track: Get image"
        if: matrix.suite == 'tracks'
        run: |
          echo "GET /api/tracks/${{ env.TRACK_ID }}/image"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/tracks/${{ env.TRACK_ID }}/image")
          echo "HTTP status: $HTTP_CODE (verwacht: 200)"
          if [ "$HTTP_CODE" = "200" ]; then
            echo "Correct: track afbeelding kan worden opgehaald"
          else
            echo "::error::Verwachtte HTTP 200, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Track: Delete image"
        if: matrix.suite == 'tracks'
        run: |
          echo "DELETE /api/tracks/${{ env.TRACK_ID }}/image"
          RESPONSE=$(curl -s -X DELETE -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/tracks/${{ env.TRACK_ID }}/image")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Track afbeelding succesvol verwijderd"
          else
            echo "::error::Verwijderen van track afbeelding gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      # ==================== MAINTENANCE TESTS ====================
      - name: "Maintenance: Database health endpoint"
        if: matrix.suite == 'maintenance'
        run: |
          echo "GET /api/db/maintenance/health"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/maintenance/health)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          DB_NAME=$(echo "$RESPONSE" | jq -r '.data.database_name')
          NEEDS_MAINTENANCE=$(echo "$RESPONSE" | jq -r '.data.needs_maintenance')
          if [ "$SUCCESS" = "true" ]; then
            echo "Database health OK - database: $DB_NAME, needs_maintenance: $NEEDS_MAINTENANCE"
          else
            echo "::error::Database health check gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Maintenance: Health endpoint shows table stats"
        if: matrix.suite == 'maintenance'
        run: |
          echo "Checking table health fields"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/maintenance/health)
          # Check for new fields: dead_tuple_ratio, modifications_since_analyze, needs_vacuum, needs_analyze
          FIRST_TABLE=$(echo "$RESPONSE" | jq -r '.data.tables[0]')
          HAS_DTR=$(echo "$FIRST_TABLE" | jq 'has("dead_tuple_ratio")')
          HAS_MSA=$(echo "$FIRST_TABLE" | jq 'has("modifications_since_analyze")')
          HAS_NV=$(echo "$FIRST_TABLE" | jq 'has("needs_vacuum")')
          HAS_NA=$(echo "$FIRST_TABLE" | jq 'has("needs_analyze")')
          if [ "$HAS_DTR" = "true" ] && [ "$HAS_MSA" = "true" ] && [ "$HAS_NV" = "true" ] && [ "$HAS_NA" = "true" ]; then
            echo "Alle nieuwe tabel health velden aanwezig"
          else
            echo "::error::Nieuwe tabel health velden ontbreken"
            echo "First table: $FIRST_TABLE"
            exit 1
          fi

      - name: "Maintenance: Status endpoint (no operation running)"
        if: matrix.suite == 'maintenance'
        run: |
          echo "GET /api/db/maintenance/status"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/maintenance/status)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          RUNNING=$(echo "$RESPONSE" | jq -r '.data.running')
          if [ "$SUCCESS" = "true" ] && [ "$RUNNING" = "false" ]; then
            echo "Status endpoint OK - geen operatie actief"
          else
            echo "::error::Status endpoint gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Maintenance: Start vacuum (async, returns 202)"
        if: matrix.suite == 'maintenance'
        run: |
          echo "POST /api/db/maintenance/vacuum (table=artist)"
          HTTP_CODE=$(curl -s -o /tmp/vacuum_response.json -w "%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/maintenance/vacuum \
            -d '{"tables": ["artist"]}')
          RESPONSE=$(cat /tmp/vacuum_response.json)
          if [ "$HTTP_CODE" = "202" ]; then
            echo "Vacuum gestart (202 Accepted)"
          else
            echo "::error::Verwachtte 202, kreeg $HTTP_CODE"
            echo "Response: $RESPONSE"
            exit 1
          fi
          # Wait for completion
          sleep 2

      - name: "Maintenance: Check status shows completed vacuum"
        if: matrix.suite == 'maintenance'
        run: |
          echo "GET /api/db/maintenance/status (after vacuum)"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/maintenance/status)
          RUNNING=$(echo "$RESPONSE" | jq -r '.data.running')
          OPERATION=$(echo "$RESPONSE" | jq -r '.data.operation')
          TABLES_SUCCESS=$(echo "$RESPONSE" | jq -r '.data.last_result.tables_success')
          if [ "$RUNNING" = "false" ] && [ "$TABLES_SUCCESS" -ge 0 ]; then
            echo "Vacuum voltooid - operation: $OPERATION, tables_success: $TABLES_SUCCESS"
          else
            echo "::error::Vacuum status check gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Maintenance: Start analyze (async, returns 202)"
        if: matrix.suite == 'maintenance'
        run: |
          echo "POST /api/db/maintenance/analyze (table=artist)"
          HTTP_CODE=$(curl -s -o /tmp/analyze_response.json -w "%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/maintenance/analyze \
            -d '{"tables": ["artist"]}')
          RESPONSE=$(cat /tmp/analyze_response.json)
          if [ "$HTTP_CODE" = "202" ]; then
            echo "Analyze gestart (202 Accepted)"
          else
            echo "::error::Verwachtte 202, kreeg $HTTP_CODE"
            echo "Response: $RESPONSE"
            exit 1
          fi
          # Wait for completion
          sleep 2

      - name: "Maintenance: Vacuum with analyze option"
        if: matrix.suite == 'maintenance'
        run: |
          echo "POST /api/db/maintenance/vacuum (table=track, analyze=true)"
          HTTP_CODE=$(curl -s -o /tmp/vacuum_analyze_response.json -w "%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/maintenance/vacuum \
            -d '{"tables": ["track"], "analyze": true}')
          if [ "$HTTP_CODE" = "202" ]; then
            echo "Vacuum met analyze gestart (202 Accepted)"
            sleep 2
            # Check status
            STATUS=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/maintenance/status)
            OPERATION=$(echo "$STATUS" | jq -r '.data.operation')
            echo "Operation was: $OPERATION"
          else
            echo "::error::Verwachtte 202, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Maintenance: Concurrent operation rejected"
        if: matrix.suite == 'maintenance'
        run: |
          echo "Testing concurrent operation rejection"
          # Start two vacuum requests simultaneously - one should get 409
          # Using background processes ensures we catch the race condition
          curl -s -o /tmp/vacuum1.json -w "\n%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/maintenance/vacuum \
            -d '{"tables": ["artist"]}' > /tmp/r1.txt &
          PID1=$!

          curl -s -o /tmp/vacuum2.json -w "\n%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/maintenance/vacuum \
            -d '{"tables": ["track"]}' > /tmp/r2.txt &
          PID2=$!

          wait $PID1 $PID2

          # Extract HTTP codes (last line of output)
          HTTP1=$(tail -1 /tmp/r1.txt)
          HTTP2=$(tail -1 /tmp/r2.txt)
          echo "Request 1 HTTP: $HTTP1, Request 2 HTTP: $HTTP2"

          # Exactly one should succeed (202) and one should fail (409)
          # Or both could succeed if the first completed before the second started (unlikely but valid)
          GOT_202=0
          GOT_409=0
          [ "$HTTP1" = "202" ] && GOT_202=$((GOT_202 + 1))
          [ "$HTTP2" = "202" ] && GOT_202=$((GOT_202 + 1))
          [ "$HTTP1" = "409" ] && GOT_409=$((GOT_409 + 1))
          [ "$HTTP2" = "409" ] && GOT_409=$((GOT_409 + 1))

          echo "Got $GOT_202 x 202 (Accepted) and $GOT_409 x 409 (Conflict)"

          if [ "$GOT_409" -ge 1 ]; then
            # At least one request was rejected - concurrent protection works
            echo "Correct: concurrent operatie correct afgehandeld"
            # Verify the 409 response has the expected error message
            if [ "$HTTP1" = "409" ]; then
              ERROR=$(jq -r '.error' /tmp/vacuum1.json)
            else
              ERROR=$(jq -r '.error' /tmp/vacuum2.json)
            fi
            if echo "$ERROR" | grep -q "al een maintenance"; then
              echo "Correct: foutmelding bevat 'al een maintenance'"
            else
              echo "::warning::Verwachtte 'al een maintenance' in foutmelding, kreeg: $ERROR"
            fi
          elif [ "$GOT_202" -eq 2 ]; then
            # Both succeeded - first completed before second started (race condition timing)
            # This is technically correct behavior but makes test less useful
            echo "::warning::Beide requests slaagden (202) - eerste was al klaar voor tweede startte"
            echo "Dit is correct gedrag maar test was niet effectief"
          else
            echo "::error::Onverwachte HTTP codes: $HTTP1 en $HTTP2"
            echo "Response 1: $(cat /tmp/vacuum1.json)"
            echo "Response 2: $(cat /tmp/vacuum2.json)"
            exit 1
          fi

          # Wait for any running operation to complete
          for i in {1..30}; do
            RUNNING=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" \
              http://localhost:${{ env.API_PORT }}/api/db/maintenance/status | jq -r '.data.running')
            [ "$RUNNING" = "false" ] && break
            sleep 1
          done

      - name: "Maintenance: Scheduler starts correctly"
        if: matrix.suite == 'maintenance'
        run: |
          echo "Testing maintenance scheduler startup..."
          # Stop current API server
          kill $(cat api.pid) 2>/dev/null || true
          sleep 1

          # Create config with maintenance scheduler enabled
          cat > test_scheduler.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 1280, "target_height": 1280, "quality": 90, "reject_smaller": true },
            "api": { "enabled": true, "keys": ["test-api-key-12345"] },
            "maintenance": {
              "scheduler": { "enabled": true, "schedule": "0 4 * * 0", "timezone": "Europe/Amsterdam" }
            }
          }
          EOF

          # Start with scheduler enabled
          ./zwfm-aerontoolbox -config=test_scheduler.json -port=${{ env.API_PORT }} > /tmp/scheduler_output.log 2>&1 &
          echo $! > api.pid

          # Wait for startup
          for i in {1..30}; do
            curl -sf http://localhost:${{ env.API_PORT }}/api/health > /dev/null 2>&1 && break
            sleep 1
          done

          # Verify health endpoint works
          RESPONSE=$(curl -s http://localhost:${{ env.API_PORT }}/api/health)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')

          # Check logs for scheduler started message
          if grep -q "Scheduler gestart" /tmp/scheduler_output.log && grep -q "maintenance" /tmp/scheduler_output.log; then
            echo "Correct: scheduler gestart met maintenance job"
          else
            echo "::warning::Scheduler log bericht niet gevonden"
            cat /tmp/scheduler_output.log
          fi

          if [ "$SUCCESS" = "true" ]; then
            echo "Correct: applicatie draait met maintenance scheduler"
          else
            echo "::error::Applicatie start niet correct met scheduler"
            exit 1
          fi

      # ==================== BACKUP TESTS ====================
      - name: "Backup: List backups (empty)"
        if: matrix.suite == 'backup'
        run: |
          echo "GET /api/db/backups"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backups)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          COUNT=$(echo "$RESPONSE" | jq -r '.data.total_count')
          if [ "$SUCCESS" = "true" ] && [ "$COUNT" = "0" ]; then
            echo "Correct: geen backups aanwezig ($COUNT)"
          else
            echo "::error::Verwachtte 0 backups, kreeg $COUNT"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Backup: Status endpoint (no backup yet)"
        if: matrix.suite == 'backup'
        run: |
          echo "GET /api/db/backup/status"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backup/status)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          RUNNING=$(echo "$RESPONSE" | jq -r '.data.running')
          if [ "$SUCCESS" = "true" ] && [ "$RUNNING" = "false" ]; then
            echo "Correct: geen backup actief"
          else
            echo "::error::Status endpoint gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Backup: Create async"
        if: matrix.suite == 'backup'
        run: |
          echo "POST /api/db/backup (compression=6)"
          HTTP_CODE=$(curl -s -o /tmp/backup_response.json -w "%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/backup \
            -d '{"compression": 6}')
          RESPONSE=$(cat /tmp/backup_response.json)
          echo "HTTP status: $HTTP_CODE (verwacht: 202)"
          echo "Response: $RESPONSE"
          if [ "$HTTP_CODE" = "202" ]; then
            echo "Backup gestart op achtergrond"
          else
            echo "::error::Verwachtte HTTP 202 Accepted, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Backup: Wait for completion and verify status"
        if: matrix.suite == 'backup'
        run: |
          echo "Wachten op backup voltooiing..."
          for i in {1..60}; do
            RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backup/status)
            RUNNING=$(echo "$RESPONSE" | jq -r '.data.running')
            if [ "$RUNNING" = "false" ]; then
              SUCCESS_STATUS=$(echo "$RESPONSE" | jq -r '.data.success')
              FILENAME=$(echo "$RESPONSE" | jq -r '.data.filename')
              STARTED_AT=$(echo "$RESPONSE" | jq -r '.data.started_at')
              ENDED_AT=$(echo "$RESPONSE" | jq -r '.data.ended_at')
              ERROR=$(echo "$RESPONSE" | jq -r '.data.error')
              echo "Status response: $RESPONSE"
              if [ "$SUCCESS_STATUS" = "true" ] && [ "$STARTED_AT" != "null" ] && [ "$ENDED_AT" != "null" ]; then
                echo "Backup voltooid: $FILENAME (started: $STARTED_AT, ended: $ENDED_AT)"
                echo "BACKUP_FILENAME=$FILENAME" >> $GITHUB_ENV
                exit 0
              elif [ "$SUCCESS_STATUS" = "true" ]; then
                echo "::error::Backup success maar started_at of ended_at ontbreekt"
                exit 1
              else
                echo "::error::Backup gefaald: $ERROR"
                exit 1
              fi
            fi
            echo "Backup nog bezig... ($i/60)"
            sleep 1
          done
          echo "::error::Backup timeout na 60 seconden"
          exit 1

      - name: "Backup: On-demand validation endpoint"
        if: matrix.suite == 'backup'
        run: |
          echo "GET /api/db/backups/${{ env.BACKUP_FILENAME }}/validate"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/${{ env.BACKUP_FILENAME }}/validate")
          VALID=$(echo "$RESPONSE" | jq -r '.data.valid')
          if [ "$VALID" = "true" ]; then
            echo "On-demand validatie OK"
          else
            echo "::error::Validatie zou moeten slagen"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Backup: Validate non-existent returns 404"
        if: matrix.suite == 'backup'
        run: |
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/aeron-backup-fake.dump/validate")
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: niet-bestaand bestand geeft 404"
          else
            echo "::error::Verwachtte 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Backup: Concurrent backup rejected"
        if: matrix.suite == 'backup'
        run: |
          echo "POST /api/db/backup (tweede backup starten terwijl eerste draait)"
          # Start eerste backup
          curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/backup \
            -d '{}' > /dev/null

          # Poll status en probeer tweede backup zodra eerste draait
          TESTED=false
          for i in {1..60}; do
            RUNNING=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" \
              http://localhost:${{ env.API_PORT }}/api/db/backup/status | jq -r '.data.running')
            if [ "$RUNNING" = "true" ]; then
              echo "Eerste backup draait, probeer tweede te starten..."
              HTTP_CODE=$(curl -s -o /tmp/concurrent_backup.json -w "%{http_code}" -X POST \
                -H "X-API-Key: ${{ env.API_KEY }}" \
                -H 'Content-Type: application/json' \
                http://localhost:${{ env.API_PORT }}/api/db/backup \
                -d '{}')
              RESPONSE=$(cat /tmp/concurrent_backup.json)
              SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
              ERROR=$(echo "$RESPONSE" | jq -r '.error')

              if [ "$HTTP_CODE" = "409" ] && [ "$SUCCESS" = "false" ] && echo "$ERROR" | grep -q "al bezig"; then
                echo "Correct: concurrent backup afgewezen (HTTP 409, error: $ERROR)"
                TESTED=true
                break
              else
                echo "::error::Verwachtte HTTP 409 met juiste error, kreeg HTTP $HTTP_CODE: $ERROR"
                exit 1
              fi
            fi
            sleep 0.1
          done

          if [ "$TESTED" = "false" ]; then
            echo "::error::Kon concurrent backup test niet uitvoeren (backup te snel klaar)"
            exit 1
          fi

          # Wacht tot backup klaar is
          for i in {1..60}; do
            RUNNING=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" \
              http://localhost:${{ env.API_PORT }}/api/db/backup/status | jq -r '.data.running')
            [ "$RUNNING" = "false" ] && break
            sleep 1
          done

      - name: "Backup: List backups (2 files)"
        if: matrix.suite == 'backup'
        run: |
          echo "GET /api/db/backups"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backups)
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          COUNT=$(echo "$RESPONSE" | jq -r '.data.total_count')
          if [ "$SUCCESS" = "true" ] && [ "$COUNT" = "2" ]; then
            echo "Correct: $COUNT backups aanwezig"
          else
            echo "::error::Verwachtte 2 backups, kreeg $COUNT"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Backup: Download file"
        if: matrix.suite == 'backup'
        run: |
          echo "GET /api/db/backups/${{ env.BACKUP_FILENAME }}"
          HTTP_CODE=$(curl -s -o /tmp/backup.dump -w "%{http_code}" \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/${{ env.BACKUP_FILENAME }}")
          FILE_SIZE=$(stat -c%s /tmp/backup.dump 2>/dev/null || echo "0")
          echo "HTTP status: $HTTP_CODE, bestandsgrootte: $FILE_SIZE bytes"
          if [ "$HTTP_CODE" = "200" ] && [ "$FILE_SIZE" -gt 0 ]; then
            echo "Backup succesvol gedownload"
          else
            echo "::error::Backup download gefaald - HTTP $HTTP_CODE, grootte $FILE_SIZE"
            exit 1
          fi

      - name: "Backup: Delete without confirmation rejected"
        if: matrix.suite == 'backup'
        run: |
          echo "DELETE /api/db/backups/${{ env.BACKUP_FILENAME }} (zonder bevestiging)"
          RESPONSE=$(curl -s -X DELETE -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/${{ env.BACKUP_FILENAME }}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: delete zonder bevestiging wordt geweigerd"
          else
            echo "::error::Delete zonder bevestiging zou geweigerd moeten worden"
            exit 1
          fi

      - name: "Backup: Delete with confirmation"
        if: matrix.suite == 'backup'
        run: |
          echo "DELETE /api/db/backups/${{ env.BACKUP_FILENAME }} (met bevestiging)"
          RESPONSE=$(curl -s -X DELETE \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "X-Confirm-Delete: ${{ env.BACKUP_FILENAME }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/${{ env.BACKUP_FILENAME }}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Backup succesvol verwijderd"
          else
            echo "::error::Backup verwijderen gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Backup: Non-existent returns 404"
        if: matrix.suite == 'backup'
        run: |
          echo "DELETE /api/db/backups/aeron-backup-nonexistent.dump"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "X-Confirm-Delete: aeron-backup-nonexistent.dump" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/aeron-backup-nonexistent.dump")
          echo "HTTP status: $HTTP_CODE (verwacht: 404)"
          if [ "$HTTP_CODE" = "404" ]; then
            echo "Correct: niet-bestaande backup geeft 404"
          else
            echo "::error::Verwachtte HTTP 404, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Backup: Invalid compression rejected"
        if: matrix.suite == 'backup'
        run: |
          echo "POST /api/db/backup (compression=15)"
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/backup \
            -d '{"compression": 15}')
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: ongeldige compressie (15) wordt geweigerd"
          else
            echo "::error::Ongeldige compressie zou geweigerd moeten worden"
            exit 1
          fi

      - name: "Backup: Path traversal blocked"
        if: matrix.suite == 'backup'
        run: |
          echo "DELETE /api/db/backups/../../../etc/passwd (path traversal poging)"
          RESPONSE=$(curl -s -X DELETE \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "X-Confirm-Delete: ../../../etc/passwd" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/../../../etc/passwd")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: path traversal wordt geblokkeerd"
          else
            echo "::error::Path traversal zou geblokkeerd moeten worden!"
            exit 1
          fi

      # ==================== SYSTEM VALIDATION TESTS ====================
      - name: "System-Validation: Startup fails without pg_dump"
        if: matrix.suite == 'system-validation'
        run: |
          echo "Testen of applicatie weigert te starten zonder pg_dump..."

          # Verberg pg_dump tijdelijk door binary te hernoemen
          PG_DUMP_PATH=$(which pg_dump)
          echo "pg_dump gevonden op: $PG_DUMP_PATH"
          sudo mv "$PG_DUMP_PATH" "${PG_DUMP_PATH}.bak"

          cat > test_backup_enabled.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 640, "target_height": 640, "quality": 85 },
            "backup": { "enabled": true, "path": "/tmp/backups" }
          }
          EOF
          mkdir -p /tmp/backups

          # Applicatie zou moeten falen met pg_dump error
          OUTPUT=$(./zwfm-aerontoolbox -config=test_backup_enabled.json -port=8891 2>&1 || true)
          echo "Output: $OUTPUT"

          # Herstel pg_dump
          sudo mv "${PG_DUMP_PATH}.bak" "$PG_DUMP_PATH"

          if echo "$OUTPUT" | grep -q "pg_dump niet gevonden"; then
            echo "Correct: applicatie weigert te starten zonder pg_dump"
          else
            echo "::error::Applicatie zou moeten falen met 'pg_dump niet gevonden' error"
            exit 1
          fi

      - name: "System-Validation: Startup succeeds with backup disabled"
        if: matrix.suite == 'system-validation'
        run: |
          echo "Testen of applicatie start met backup uitgeschakeld (geen pg_dump nodig)..."

          # Verberg pg_dump tijdelijk
          PG_DUMP_PATH=$(which pg_dump)
          sudo mv "$PG_DUMP_PATH" "${PG_DUMP_PATH}.bak"

          cat > test_backup_disabled.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 640, "target_height": 640, "quality": 85 },
            "backup": { "enabled": false }
          }
          EOF

          ./zwfm-aerontoolbox -config=test_backup_disabled.json -port=8892 &
          PID=$!
          sleep 3

          # Herstel pg_dump
          sudo mv "${PG_DUMP_PATH}.bak" "$PG_DUMP_PATH"

          # Check of applicatie draait
          if curl -sf http://localhost:8892/api/health > /dev/null 2>&1; then
            echo "Correct: applicatie start zonder pg_dump als backup uitgeschakeld is"
            kill $PID 2>/dev/null || true
          else
            echo "::error::Applicatie zou moeten starten met backup.enabled=false"
            kill $PID 2>/dev/null || true
            exit 1
          fi

      - name: "System-Validation: Custom pg_dump path validated"
        if: matrix.suite == 'system-validation'
        run: |
          echo "Testen of custom pg_dump pad wordt gevalideerd..."
          cat > test_custom_path.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 640, "target_height": 640, "quality": 85 },
            "backup": { "enabled": true, "path": "/tmp/backups", "pg_dump_path": "/nonexistent/pg_dump" }
          }
          EOF

          OUTPUT=$(./zwfm-aerontoolbox -config=test_custom_path.json -port=8893 2>&1 || true)
          echo "Output: $OUTPUT"

          if echo "$OUTPUT" | grep -q "pg_dump niet gevonden op pad"; then
            echo "Correct: custom pad wordt gevalideerd"
          else
            echo "::error::Custom pad zou gevalideerd moeten worden"
            exit 1
          fi

      - name: "System-Validation: Custom pg_restore path validated"
        if: matrix.suite == 'system-validation'
        run: |
          echo "Testen of custom pg_restore pad wordt gevalideerd..."

          cat > test_custom_restore.json << 'EOF'
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 640, "target_height": 640, "quality": 85 },
            "backup": { "enabled": true, "path": "/tmp/backups", "pg_restore_path": "/nonexistent/pg_restore" }
          }
          EOF

          OUTPUT=$(./zwfm-aerontoolbox -config=test_custom_restore.json -port=8894 2>&1 || true)
          echo "Output: $OUTPUT"

          if echo "$OUTPUT" | grep -q "pg_restore niet gevonden op pad"; then
            echo "Correct: custom pg_restore pad wordt gevalideerd"
          else
            echo "::error::Custom pg_restore pad zou gevalideerd moeten worden"
            exit 1
          fi

      - name: "System-Validation: Valid custom paths work"
        if: matrix.suite == 'system-validation'
        run: |
          echo "Testen of geldige custom paden werken..."
          PG_DUMP_PATH=$(which pg_dump)
          PG_RESTORE_PATH=$(which pg_restore)
          echo "pg_dump: $PG_DUMP_PATH"
          echo "pg_restore: $PG_RESTORE_PATH"

          cat > test_valid_paths.json << EOF
          {
            "database": { "host": "localhost", "port": "5433", "name": "aeron_db", "user": "aeron", "password": "aeron123", "schema": "aeron", "sslmode": "disable" },
            "image": { "target_width": 640, "target_height": 640, "quality": 85 },
            "backup": { "enabled": true, "path": "/tmp/backups", "pg_dump_path": "$PG_DUMP_PATH", "pg_restore_path": "$PG_RESTORE_PATH" }
          }
          EOF

          ./zwfm-aerontoolbox -config=test_valid_paths.json -port=8895 &
          PID=$!
          sleep 3

          if curl -sf http://localhost:8895/api/health > /dev/null 2>&1; then
            echo "Correct: applicatie start met geldige custom paden"
            kill $PID 2>/dev/null || true
          else
            echo "::error::Applicatie zou moeten starten met geldige custom paden"
            kill $PID 2>/dev/null || true
            exit 1
          fi

      # ==================== S3 SYNC TESTS ====================
      - name: "S3: Start MinIO container"
        if: matrix.suite == 's3'
        run: |
          echo "MinIO container starten..."
          # Remove any existing container from previous runs
          docker rm -f aeron-test-minio 2>/dev/null || true
          docker run -d --name aeron-test-minio \
            -p 9000:9000 -p 9001:9001 \
            -e MINIO_ROOT_USER=minioadmin \
            -e MINIO_ROOT_PASSWORD=minioadmin123 \
            minio/minio:latest server /data --console-address ":9001"

      - name: "S3: Wait for MinIO and create bucket"
        if: matrix.suite == 's3'
        run: |
          echo "Wachten op MinIO..."
          for i in {1..30}; do
            if curl -sf http://localhost:9000/minio/health/live > /dev/null 2>&1; then
              echo "MinIO is klaar"
              break
            fi
            sleep 1
          done

          # Install MinIO client
          curl -sL https://dl.min.io/client/mc/release/linux-amd64/mc -o /tmp/mc
          chmod +x /tmp/mc

          # Configure MinIO client
          /tmp/mc alias set testminio http://localhost:9000 minioadmin minioadmin123

          # Create test bucket
          /tmp/mc mb testminio/aeron-backups
          echo "Bucket 'aeron-backups' aangemaakt"

      - name: "S3: Restart API with S3 config"
        if: matrix.suite == 's3'
        run: |
          echo "API server herstarten met S3 configuratie..."
          kill $(cat api.pid) 2>/dev/null || true

          cat > test_s3_config.json << 'EOF'
          {
            "database": {
              "host": "localhost",
              "port": "5433",
              "name": "aeron_db",
              "user": "aeron",
              "password": "aeron123",
              "schema": "aeron",
              "sslmode": "disable"
            },
            "image": {
              "target_width": 1280,
              "target_height": 1280,
              "quality": 90,
              "reject_smaller": true
            },
            "api": {
              "enabled": true,
              "keys": ["test-api-key-12345"]
            },
            "backup": {
              "enabled": true,
              "path": "/tmp/backups",
              "retention_days": 30,
              "max_backups": 5,
              "default_compression": 6,
              "s3": {
                "enabled": true,
                "bucket": "aeron-backups",
                "region": "us-east-1",
                "endpoint": "http://localhost:9000",
                "access_key_id": "minioadmin",
                "secret_access_key": "minioadmin123",
                "path_prefix": "test-backups/",
                "force_path_style": true
              }
            }
          }
          EOF

          ./zwfm-aerontoolbox -config=test_s3_config.json -port=${{ env.API_PORT }} &
          echo $! > api.pid
          for i in {1..30}; do
            curl -sf http://localhost:${{ env.API_PORT }}/api/health > /dev/null 2>&1 && break
            sleep 1
          done
          echo "API server gestart met S3 sync ingeschakeld"

      - name: "S3: Verify API started with S3 config"
        if: matrix.suite == 's3'
        run: |
          echo "GET /api/db/backup/status (controleren of status endpoint werkt)"
          RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backup/status)
          echo "Response: $RESPONSE"

          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "true" ]; then
            echo "Correct: backup status endpoint werkt"
          else
            echo "::error::Backup status endpoint gefaald"
            exit 1
          fi

      - name: "S3: Create backup and verify sync"
        if: matrix.suite == 's3'
        run: |
          echo "POST /api/db/backup (met S3 sync)"
          HTTP_CODE=$(curl -s -o /tmp/s3_backup_response.json -w "%{http_code}" -X POST \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H 'Content-Type: application/json' \
            http://localhost:${{ env.API_PORT }}/api/db/backup \
            -d '{"compression": 6}')

          if [ "$HTTP_CODE" != "202" ]; then
            echo "::error::Verwachtte HTTP 202, kreeg $HTTP_CODE"
            cat /tmp/s3_backup_response.json
            exit 1
          fi
          echo "Backup gestart (HTTP 202)"

      - name: "S3: Wait for backup and S3 sync completion"
        if: matrix.suite == 's3'
        run: |
          echo "Wachten op backup en S3 sync voltooiing..."
          for i in {1..90}; do
            RESPONSE=$(curl -s -H "X-API-Key: ${{ env.API_KEY }}" http://localhost:${{ env.API_PORT }}/api/db/backup/status)
            RUNNING=$(echo "$RESPONSE" | jq -r '.data.running')

            if [ "$RUNNING" = "false" ]; then
              echo "Status response: $RESPONSE"
              SUCCESS=$(echo "$RESPONSE" | jq -r '.data.success')
              FILENAME=$(echo "$RESPONSE" | jq -r '.data.filename')
              S3_SYNCED=$(echo "$RESPONSE" | jq -r '.data.s3_sync.synced')
              S3_ERROR=$(echo "$RESPONSE" | jq -r '.data.s3_sync.error')

              if [ "$SUCCESS" != "true" ]; then
                echo "::error::Backup gefaald"
                exit 1
              fi

              if [ "$S3_SYNCED" = "true" ]; then
                echo "Backup voltooid: $FILENAME"
                echo "S3 sync succesvol!"
                echo "S3_BACKUP_FILENAME=$FILENAME" >> $GITHUB_ENV
                exit 0
              else
                echo "::error::S3 sync gefaald: $S3_ERROR"
                exit 1
              fi
            fi
            echo "Backup/sync nog bezig... ($i/90)"
            sleep 1
          done
          echo "::error::Backup/S3 sync timeout na 90 seconden"
          exit 1

      - name: "S3: Verify file exists in MinIO"
        if: matrix.suite == 's3'
        run: |
          echo "Controleren of backup in MinIO staat..."
          S3_KEY="test-backups/${{ env.S3_BACKUP_FILENAME }}"
          echo "Zoeken naar: $S3_KEY"

          # List objects in bucket
          OBJECTS=$(/tmp/mc ls testminio/aeron-backups/test-backups/)
          echo "Objecten in bucket: $OBJECTS"

          if echo "$OBJECTS" | grep -q "${{ env.S3_BACKUP_FILENAME }}"; then
            echo "Correct: backup bestand gevonden in MinIO"
          else
            echo "::error::Backup bestand niet gevonden in MinIO"
            exit 1
          fi

      - name: "S3: Delete backup and verify S3 deletion"
        if: matrix.suite == 's3'
        run: |
          echo "DELETE /api/db/backups/${{ env.S3_BACKUP_FILENAME }}"
          RESPONSE=$(curl -s -X DELETE \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "X-Confirm-Delete: ${{ env.S3_BACKUP_FILENAME }}" \
            "http://localhost:${{ env.API_PORT }}/api/db/backups/${{ env.S3_BACKUP_FILENAME }}")
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" != "true" ]; then
            echo "::error::Backup verwijderen gefaald"
            echo "Response: $RESPONSE"
            exit 1
          fi
          echo "Backup lokaal verwijderd"

          # Give S3 deletion time to complete
          sleep 2

          # Verify deleted from S3
          OBJECTS=$(/tmp/mc ls testminio/aeron-backups/test-backups/ 2>/dev/null || echo "")
          if echo "$OBJECTS" | grep -q "${{ env.S3_BACKUP_FILENAME }}"; then
            echo "::error::Backup bestand nog steeds in MinIO na verwijdering"
            exit 1
          else
            echo "Correct: backup ook verwijderd uit MinIO"
          fi

      - name: "S3: Cleanup MinIO container"
        if: matrix.suite == 's3' && always()
        run: |
          docker stop aeron-test-minio 2>/dev/null || true
          docker rm aeron-test-minio 2>/dev/null || true

      # ==================== EDGE CASE TESTS ====================
      - name: "Edge: Upload to non-existent artist"
        if: matrix.suite == 'edge-cases'
        run: |
          echo "POST /api/artists/${{ env.FAKE_UUID }}/image (niet-bestaande artiest)"
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.FAKE_UUID }}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/500"}')
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          if [ "$SUCCESS" = "false" ]; then
            echo "Correct: upload naar niet-bestaande artiest wordt geweigerd"
          else
            echo "::error::Upload naar niet-bestaande artiest zou moeten falen"
            exit 1
          fi

      - name: "Edge: Invalid UUID returns 400"
        if: matrix.suite == 'edge-cases'
        run: |
          echo "POST /api/artists/not-a-uuid/image (ongeldige UUID)"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/not-a-uuid/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/500"}')
          echo "HTTP status: $HTTP_CODE (verwacht: 400)"
          if [ "$HTTP_CODE" = "400" ]; then
            echo "Correct: ongeldige UUID geeft 400 Bad Request"
          else
            echo "::error::Verwachtte HTTP 400, kreeg $HTTP_CODE"
            exit 1
          fi

      - name: "Edge: No image source rejected"
        if: matrix.suite == 'edge-cases'
        run: |
          echo "POST /api/artists/${{ env.ARTIST_ID }}/image (geen afbeelding meegegeven)"
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.ARTIST_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d '{}')
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          ERROR=$(echo "$RESPONSE" | jq -r '.error')
          if [ "$SUCCESS" = "false" ] && echo "$ERROR" | grep -q 'afbeelding is verplicht'; then
            echo "Correct: request zonder afbeelding wordt geweigerd"
            echo "Foutmelding: $ERROR"
          else
            echo "::error::Request zonder afbeelding zou geweigerd moeten worden met juiste foutmelding"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Edge: Both URL and image rejected"
        if: matrix.suite == 'edge-cases'
        run: |
          echo "POST /api/artists/${{ env.ARTIST_ID }}/image (zowel URL als image)"
          RESPONSE=$(curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.ARTIST_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://example.com/img.jpg","image":"data:image/jpeg;base64,/9j/4AAQ"}')
          SUCCESS=$(echo "$RESPONSE" | jq -r '.success')
          ERROR=$(echo "$RESPONSE" | jq -r '.error')
          if [ "$SUCCESS" = "false" ] && echo "$ERROR" | grep -q 'gebruik f URL f upload, niet beide'; then
            echo "Correct: zowel URL als image wordt geweigerd"
            echo "Foutmelding: $ERROR"
          else
            echo "::error::Request met zowel URL als image zou geweigerd moeten worden"
            echo "Response: $RESPONSE"
            exit 1
          fi

      - name: "Edge: Concurrent uploads"
        if: matrix.suite == 'edge-cases'
        run: |
          echo "Testen van 3 gelijktijdige uploads..."
          ARTIST_ID2=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT artistid FROM aeron.artist OFFSET 1 LIMIT 1;" | tr -d ' ')
          TRACK_ID=$(docker exec aeron-test-db psql -U aeron -d aeron_db -t -c "SELECT titleid FROM aeron.track LIMIT 1;" | tr -d ' ')
          echo "Artist 1: ${{ env.ARTIST_ID }}"
          echo "Artist 2: $ARTIST_ID2"
          echo "Track: $TRACK_ID"

          curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${{ env.ARTIST_ID }}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/1500"}' > /tmp/r1.json &

          curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/artists/${ARTIST_ID2}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/1500"}' > /tmp/r2.json &

          curl -s -X POST -H "X-API-Key: ${{ env.API_KEY }}" \
            "http://localhost:${{ env.API_PORT }}/api/tracks/${TRACK_ID}/image" \
            -H 'Content-Type: application/json' \
            -d '{"url":"https://picsum.photos/1500"}' > /tmp/r3.json &

          wait
          echo "Upload 1: $(cat /tmp/r1.json | jq -r '.success')"
          echo "Upload 2: $(cat /tmp/r2.json | jq -r '.success')"
          echo "Upload 3: $(cat /tmp/r3.json | jq -r '.success')"

          FAILED=0
          jq -e '.success == true' /tmp/r1.json > /dev/null || FAILED=1
          jq -e '.success == true' /tmp/r2.json > /dev/null || FAILED=1
          jq -e '.success == true' /tmp/r3.json > /dev/null || FAILED=1

          if [ "$FAILED" = "0" ]; then
            echo "Alle 3 gelijktijdige uploads succesvol"
          else
            echo "::error::Een of meer gelijktijdige uploads gefaald"
            exit 1
          fi

      # ==================== CLEANUP ====================
      - name: Stop API server
        if: always()
        run: |
          [ -f api.pid ] && kill $(cat api.pid) 2>/dev/null || true

      - name: Cleanup
        if: always()
        run: |
          cd tests && docker compose -f docker-compose.test.yml down -v 2>/dev/null || true
          rm -f test_*.png test_*.json /tmp/r*.json /tmp/backup*.dump 2>/dev/null || true
